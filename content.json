[{"title":"前端菜单检索功能的实现","date":"2017-03-15T12:49:13.000Z","path":"2017/03/15/前端菜单检索功能的实现/","text":"日常吐槽 程序这一行的工作为什么总是这么忙呢，大概要么是程序死循环了要么是做程序的过程死循环了吧。 好的，此次要介绍的是我再去年差不多这个时候实现的一个需求：纯前端的一个json迭代型的菜单数据检索功能；可以看一下基本效果如下图： 总的来说，还是相对比较简单的，注意细分步骤，每步需要达到的效果是什么；然后在去对每一步进行代码实现；我们在做别的需求的时候基本思路按这个来是没啥大毛病的；这个需求当时我是用了一天左右时间完成；然后整个到既有系统和调试，差不多合计两天左右吧；我印象最深的就是：当时的系统仅限IE使用，我只能用IE调试；然后那个调试工具就不说怎么难用，就崩溃的频率够让人抓狂了。 内容概要 在本篇文章中,您将看到以下内容 如何分析需求的实现步骤 输入框常用事件总结及其合理性选择 迭代型数据的检索方案及函数节流问题 按照制定规则排序数据的实现 搜索结果与正常操作之间的联动 用户体验方面的优化方向 需求分析 对上面的gif仔细分析，我们基本可以把整个搜索模块分析出如下内容 搜索图标（放大镜）的创建，搜索输入框的创建，搜索输入框显隐事件，搜索输入框锚定事件（因为搜索模块具有一定的权限限制，故为动态生成的）； 输入事件，检索菜单数据，高亮检索关键词，按照菜单深度，菜单使用频率，菜单匹配程度等需求排序 点击搜索结果，跳转到对应页面，并定位到对应菜单； 再次搜索时菜单的响应 总共四个步骤，思路清晰，接下来就是代码实现的问题了； 注： 以下代码是基于jq框架对页面进行模块化开发的代码，仅提供一种实现思路，各位可按照自己实际情况进行开发。 内容实现 1. 主模块的划分12345678910111213141516171819202122//页面的脚本部分主要由一个Page的构造函数实例化执行；即(function(win)&#123; function Page()&#123; //...... &#125; Page.XX = (function()&#123; //...... &#125;)() //...... return (new Page()).Init();&#125;)(window)//其中，本次探讨的菜单检索功能模块处于构造函数的菜单栏模块的一个子模块；即Page.MenuFrame.seachMenu = (function()&#123; //.....&#125;)()//以下的代码部分，除非特别标定，我将以menuSeach表示整个搜索菜单模块；//以下的代码部分，除非特别标定，this,that的指向均表示指向menuSeach模块//... 2. 主控件的创建这里是相对容易部分，主要目标是根据后台返回的权限值在对应位置生成搜索菜单，然后创建一个具有锚定功能的输入框，并与搜索菜单绑定调用事件。参考可如下： 12345678910111213141516171819202122232425menuSeach.createSeachMenu = function()&#123; //根据返回的权限 if(premission)&#123; XX.append(&quot;seachButton&quot;);//插入搜索菜单按钮 YY.append(&quot;seachInput&quot;);//插入输入框按钮 ZZ.append(&quot;anchorButton&quot;);//插入锚定按钮 //绑定事件 //点击菜单下拉 XX.on(&quot;click&quot;, &quot;seachButton&quot;, function()&#123; //根据锚定状态anchorState是否相应下拉搜索框 var anchorState = ... if(!anchorState)&#123; seachInput.slideDown(); &#125; &#125;); //绑定锚定事件 YY.on(&quot;click&quot;, anchorButton, function()&#123; //此处将锚定状态取反即可 //具体操作视自己存储锚定状态的方法而定 //... &#125;) &#125;&#125; 3. 对输入框事件的选择，对检索数据的实施，对检索结果的排序；这一步也将是此篇文章介绍的重点部分3.1 输入框事件怎么选 我们常用的输入框事件主要有 focus, blur, keyup, keydown, keypress, input, change, click; 其余事件因和我们这次讨论的需求相关性不大，暂且不在此次讨论中；我们本次需求主要是要针对输入的时候及时的进行检索；对这几个事件适合度，我们来分析一下： 事件名 触发时间 针对此处需求的优缺点 focus 聚焦时触发 单次触发，不符需求 keypress 按键按压住时触发 打字的时候是不同的键位快速的击发，并不存在某特定键位按压住不动的情况，不符需求 click 单击时触发 单次触发，不符需求 blur 失焦时触发 单次触发，本次需要及时搜索响应，失焦比较适合有按钮类型的搜索 change 内容改变时触发 不符合 请参考3.1.1的详细解释 keydown 键位按下时触发 不符需求，这个很多人容易混，请参考3.1.2的详细解释 keyup 聚焦时触发 符合需求请参考3.1.2的详细解释 input 聚焦时触发 符合需求，H5新出的事件，但是不兼容IE8 以上是对我列举的几个input事件进行比对的结果，事实上，任何遇到需要及时响应输入框内容时都可参照这块内容的总结；以上表中有change，input, keydown, keyup很相似的事件，似乎都满足，但是仔细体会就会发现差别 3.1.1 change为什么不能及时响应change事件表面理解为内容改变时即触发事件，然而实际使用中，该事件的触发并非实时的，而是输入框失焦事件触发前才会比对内容是否改变；参考如下：12345678910111213var input = document.querySelector(&quot;input&quot;);input.addEventListener(&quot;blur&quot;, function()&#123; console.log(1);&#125;);input.addEventListener(&quot;change&quot;, function()&#123; console.log(2);&#125;);//执行结果// 2// 1 3.1.2 keydown 和 keyup 怎么选择的顾名思义：keydown即按键按下，keyup即按键弹起；很多新手总觉的这两个事件没啥区别，随便用；然后遇到问题又抱怨js漏洞多，bug多；很多时候，问题需要从自己身上找起；这几个事件看我用一张图解决他们的区别 意思很明显，即keydown的时候我们拿不到用户刚输入的值，自然去检索的话查出的数据是不正确的；我们也可以用代码来测试一下123456789101112131415161718192021222324var input = document.querySelector(&quot;input&quot;);input.value = 12;//模拟已经输入了的值input.addEventListener(&quot;keyup&quot;, function()&#123; console.log(&quot;keyup时，值为：&quot; + this.value);&#125;);input.addEventListener(&quot;input&quot;, function()&#123; console.log(&quot;input时，值为：&quot; + this.value);&#125;);input.addEventListener(&quot;keypress&quot;, function()&#123; console.log(&quot;keypress时，值为：&quot; + this.value);&#125;);input.addEventListener(&quot;keydown&quot;, function()&#123; console.log(&quot;keydown时，值为：&quot; + this.value);&#125;);// 然后输入 3 ,将输出一下结果：// keydown时，值为：12// keypress时，值为：12// input时，值为：123// keyup时，值为：123 以上是对input的事件来了个小总结，也不想为这内容单独列个博文了。针对此次需求是要及时响应，我们把事件圈定在input和keyup上；考虑到兼容性，此处我选择的是监听keyup事件。 3.2 怎么去检索数据及函数节流问题 首先，我们拿到的数据是迭代型的json数据，这种数据的典型形式如下：123456789101112131415161718[ &#123; id: &quot;&quot;, name: &quot;&quot;, children: [ &#123; id: &quot;&quot;, name: &quot;&quot;, children: [] &#125;, &#123; id: &quot;&quot;, name: &quot;&quot;, children: [] &#125; ] &#125;] 从算法的角度来说，数据的扁平化更有利于数据的查询效率；因此，我们数据的检索第一步即是用迭代对数据进行扁平化化处理，由于此处只需要进行一次，比起后续数据往复的迭代检索，是要好很多的；除此之外，我们需要在重组的同时加入一些必要迭代信息，方便我们后续检索时的显示； 12345678910111213141516menuSeach.reformMenu = function(arrMenu, deep, road, roadIndex,result)&#123; result = result || []; //此数组方法已在全局做兼容处理，具体方法的使用请参照我的数组方法总结博文 arrMenu.forEach(function(v)&#123; road = road ? road + &quot;/&quot; + v.name : v.name; roadIndex = roadIndex ? roadIndex + &quot;/&quot; + v.id : v.id; v.deep = deep || 1; v.road = road; v.roadIndex = roadIndex; result.push(v); if(v.children &amp;&amp; v.children.length)&#123; this.reformMenu(v.children, deep+1, road, roadIndex); &#125; &#125;,this) return result;&#125; 该方法通过迭代的形式，将迭代型数据扁平化，这种操作方法在写业务逻辑时经常会需要；还是有必要掌握的。以下，我通过模拟数据转换以下，看看转换后的数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//模拟数据如下：var data = [ &#123; id: &quot;1&quot;, name: &quot;1&quot;, children: [ &#123; id: &quot;1.1&quot;, name: &quot;1.1&quot;, children: [] &#125;, &#123; id: &quot;1.2&quot;, name: &quot;1.2&quot;, children: [ &#123; id: &quot;1.2.1&quot;, name: &quot;1.2.1&quot;, children: [] &#125; ] &#125; ] &#125;];//经过处理后的数据如下var result = this.reformMenu(data);result = [ &#123; &quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;1&quot;, &quot;children&quot;: [ &#123; &quot;id&quot;: &quot;1.2&quot;, &quot;name&quot;: &quot;1.2&quot;, &quot;children&quot;: [//此处省略...], &quot;deep&quot;: 1, &quot;road&quot;: &quot;1&quot;, &quot;roadIndex&quot;: 0 &#125;, &#123; &quot;id&quot;: &quot;1.1&quot;, &quot;name&quot;: &quot;1.1&quot;, &quot;children&quot;: [], &quot;deep&quot;: 1, &quot;road&quot;: &quot;1/1.1&quot;, &quot;roadIndex&quot;: &quot;0/0&quot; &#125;, &#123; &quot;id&quot;: &quot;1.2&quot;, &quot;name&quot;: &quot;1.2&quot;, &quot;children&quot;: [//此处省略...], &quot;deep&quot;: 1, &quot;road&quot;: &quot;1/1.1/1.2&quot;, &quot;roadIndex&quot;: &quot;0/0/1&quot; &#125;, &#123; &quot;id&quot;: &quot;1.2.1&quot;, &quot;name&quot;: &quot;1.2.1&quot;, &quot;children&quot;: [], &quot;deep&quot;: 1, &quot;road&quot;: &quot;1/1.1/1.2/1.2.1&quot;, &quot;roadIndex&quot;: &quot;0/0/1/0&quot; &#125; ] 这就是处理后的扁平化数据了，然后我们再根据用户输入的内容进行遍历检索；而不必再检索中迭代了；然后这里有个需求就是需要把匹配的文字标红；这个我们用正则很容易就写出来了，如下： 1234567891011//因为此处我们需要对过滤后的数据中的字段加以改变；因此，这里我们选中map方法而不是filter方法menuSeach.seachProgress = function(seachValue)&#123; this.seachResult = this.reformMenuData .map(function(v)&#123; if(v.name.indexOf(seachValue) != -1)&#123; v._name = v.name.replace(new RegExp(seachValue,&quot;g&quot;), &quot;&lt;a&gt;&quot; + seachValue + &quot;&lt;/a&gt;&quot;)); return v; &#125; &#125;);&#125;//通过正则匹配的方式给文字加一个标签来控制匹配高亮//此处的匹配是通过字符串的indexOf来查询的，亦可用正则的形式进行匹配；根据自己需求合理选择方法 由于我们监听的是keyup事件，这种类型的事件有个特点就是高频触发性，也就是触发频率很大；而我们触发后需要一个检索过程；事实上，在中文检索中，我们在确定文字之前的keyup事件都是无意义的，但是我们也不能排除英文菜单名字存在的可能性；基于此我们的函数节流主要是利用定时器来做的；如果你对函数节流概念不清楚，你可以点击这里了解一下什么叫函数节流;123456if(this.seachInterval)&#123; clearTimeout(this.seachInterval);&#125;this.seachInterval = setTimeout(function()&#123; that.seachProgress(keyword);&#125;,this.intervalTime); 3.3 检索结果的排序实现 这一步的操作主要是排序的实现，我们已经将检索结果存在一个扁平化的数据数组中了，然后只要按既定规则使用Array.prototype.sort去排序即可，我这的需求是按照深度，使用频率，匹配程度三者相关联来排序的；参照如下123456789this.seachResult.sort(function(prev,now)&#123; if(prev.matchValue &gt; now.matchValue)&#123; return 1; &#125;else if(prev.matchValue &lt; now.matchValue)&#123; return -1; &#125;else&#123; if()&#123;&#125;//....再按照深度，使用频率进行比较 &#125;&#125;); 其中深度即我们数据中的deep字段； 使用频率我们可以在菜单的点击事件中处理，每点击一次，该菜单的点击次数+1，为了详尽的统计，我们可以将使用频次最高的前10名存储到本地存储；然后下次系统进入的时候读取配置文件加载频次数据就好了 匹配程度，实时上后续考虑到工作量的问题，我并未作匹配度的计算，因为涉及到语法的问题；比如我想输入”知识”，但是错误的输入”知是”；那么这里就有个匹配度了；想到的一个解决方案是将用户输入的文字按 split(“”)分割成数组，然后每单个文字检索，每匹配一个文字，匹配度+1；最后汇总单个菜单的匹配度；参考如下： 1234567891011121314151617181920212223242526272829303132//用户输入: &quot;模块化&quot;//默认检索var result = menuArr.map(function(v)&#123; //...&#125;);//加入匹配度计算var searchWordArr = input.value.split(&quot;&quot;); //[&quot;模&quot;,&quot;块&quot;,&quot;化&quot;], matchResult = [], result = [];//遍历检索var matchResult = matchResult.concat(searchWordArr.map(function(v)&#123; return menuArr.map(function(v1)&#123; // v为本次检索的关键字 //... &#125;);&#125;));//此时拿到的matchResult数组是所有匹配的菜单数据，然后进行数组去重来计算匹配度matchResult.forEach(function(v)&#123; var index = //...判断v是否已在result里;some遍历 if(index != -1)&#123; result[index].matchValue += 1; &#125;else&#123; v.matchValue = 1; result.push(v); &#125;&#125;);//最后进行匹配时，matchValue即匹配度，越大越匹配//但此种匹配度计算有个问题，例如有个菜单&quot;模样块状性化验&quot;；这同样匹配了&quot;模块化&quot;；且匹配值最高，但是这从语法结构来说并不是很匹配的结果//所以完整的匹配度计算还涉及到语法的相关知识，目前我看来纯前端的检索是不能完美实现的 3.4 检索结果与系统之间的联动 后续内容都是相对简单了，结果出来了；按照结果遍历出结构放到结果显示容器中就好了，然后有个联动即点击结果要逐一打开菜单的问题；这就是我们当初在一维化菜单数据时roadIndex的作用了；每一个菜单我们都绑定了点击事件，事件中会展开下一级菜单，有链接则打开链接；我们现在联动需要做的就是遍历打开就好了;参照如下：1234567this.searchResultBox.on(&quot;click&quot;, &quot;li&quot;, function()&#123; var roadArr = v.roadIndex.split(&quot;/&quot;); roadArr.forEach(function(v)&#123; this.menuBox.find(&quot;.li[data-id=v]&quot;).click(); //收起结果等后续操作 &#125;,this);&#125;); 3.5 用户体验方面的优化方向 以上我们的讨论只是基于最简单的功能实现；实际上我做的页面还有很多联动优化；包括大家做的时候也可以朝这些方向做些优化；以下总结一下就不一一演示了 可以对菜单的快速显示加入快捷键；快捷键的存在可以方便用户快速呼出搜索框检索菜单，例如 Alt + s; 菜单数量过少时，则没必要存在搜索功能，十几二十多个菜单一眼就看完的则没必要加入这么一个模块，这整个搜索模块也有近300行的代码； 菜单搜索输入框的锚定状态可以存储在本地存储；每次加载的时候读取状态值；去匹配用户的操作习惯，避免让用户重复不必要的工作； 可以适当的加一些提示框；例如：一般菜单只有最底级才有链接指引iframe跳转到新页面；当用户连续点击菜单超过4-6次仍未发生跳转页面，很有可能是用户找不到菜单在哪了；这时我们可以出一个弹层提示框提醒用户是否找不到菜单，试试搜索功能；同时，为了不过多的干扰用户的正常使用，这个提示框应该能够定时3-4秒左右自动消失，然后重新计点击数；提示框还应当有个不再提示的永久关闭按钮，然后将状态记录到本地存储中；这样就很好的方便用户的操作，又不至于过度干扰用户行为； 在检索结果的显示列表中可以提供一些快捷键给用户使用，例如：回车键默认点击匹配项第一项，键盘↑，↓可以用来移动当前聚焦匹配项；然后回车跳转；这种功能则比较适合对系统有较为熟练的使用经验的用户使用，很大程度上节省了用户在键盘 与鼠标操作之间切换的时间； 在用户再次呼出输入框的时候可以给搜索框的内容一个全选this.searchInput.select()；如果用户想以此内容继续搜索，则可以按→后加上文字；如果用户想清空原有内容发起新搜索，则可以直接输入关键字替换；这样给用户节省了用鼠标去划选内容，按删除键的时间； 除此之外，还能优化一下如何实现用户输入英文拼音检索中文菜单的功能，如用户输入”zhishi”，然后检索”知识”呢？这就需要前端准备一份字典了；有兴趣的可以看看这篇文章 以上优化方向都是针对用户体验提出的，实际开发中可以按照自己的需求合理性选择；总的来说，就是要最贴近用户群体的使用习惯去开发出一些合理性功能，才能获得用户使用后的好感。 总结 本篇博文主要介绍了前端检索实现json数据的实现的方式；总结一下开发中的重点就是 合理拆分实现步骤，然后模块化开发，组装 区分清楚输入框事件的触发规则，合理的选择 函数节流的使用 用户体验的优化，后续功能的提升 好了，本篇博文就到这了，如果你有耐心看到这，说明你也了然于胸了；至于源码，只要思路对了，码码都是路，谢谢~","tags":[{"name":"前端","slug":"前端","permalink":"https://404blog.cn/tags/前端/"},{"name":"JS","slug":"JS","permalink":"https://404blog.cn/tags/JS/"},{"name":"原创","slug":"原创","permalink":"https://404blog.cn/tags/原创/"},{"name":"菜单检索","slug":"菜单检索","permalink":"https://404blog.cn/tags/菜单检索/"}]},{"title":"ES2016数组新增遍历方法的使用环境总结","date":"2017-03-07T14:14:44.000Z","path":"2017/03/07/ES5新增遍历方法总结/","text":"日常吐槽 其实当我坐在公交车上用手机敲下这个标题的时候，我还在迟疑要不要写这么一篇总结。 一来ES5新增的这几个遍历方法网上早就是铺天盖地的基础介绍，随手检索一下就千篇一律的文章; 二来可即便如此，我发现很多的团队成员却依然沉醉在ES3的for循环里久久不能自拔，再或者就是不管什么情况的循环，只要forEach就好了，只会forEach就好了！技术不懂得更新，那还和咸鱼有什么区别呢~ 所以这里我就根据我前段时间写的大量的业务代码来总结一下新增的这几个方法，欢迎指出问题及补充！ 内容概要 在本篇文章总价中,您将看到以下内容 ES5数组新增了哪些遍历方法 ES5数组新增的方法的使用概述 ES5数组新增方法的合适使用环境 利用ES5新增的方法，我们可衍生出的写法 内容开始 1. 新增的遍历方法及其含义 这块部分是网上同类化文章最多的部分，在此我并不想过多的表述；我觉得我的博客应该定位于在有基础知识的前提下去探索不要脸的套路与技术及衍生发展，而不是反复的介绍基础知识，程序这行还是需要会自己学习的能力的；这就好比我在介绍怎么和女友亲亲妮妮的了，你却说你没女朋友~~~; 不过为了照顾部分看众，我还是总结了一个表格概述基础内容，如您需要更多信息，我建议您点击这里查看张鑫旭大神的这篇详细介绍文章； 方法名 传参形式 备注 forEach callback,[ thisObject] 返回undefined map callback,[ thisObject] 返回callback函数return的值所组成的新数组 filter callback,[ thisObject] 返回callback函数return的值为真值的对应元素所组成的新数组 some callback,[ thisObject] 返回布尔值，特性：匹配到真值一次即停止遍历 every callback,[ thisObject] 返回布尔值，特性：匹配到假值一次即停止遍历 indexOf searchElement[, fromIndex] 返回匹配元素所在的序列号 lastIndexOf searchElement[, fromIndex] 返回匹配元素所在的序列号 reduce callback[, initialValue] 返回迭代值，callback函数的首个参数即为上次遍历的return值或initialValue reduceRight callback[, initialValue] 返回迭代值，callback函数的首个参数即为上次遍历的return值或initialValue 在这些方法中：forEach，map，filter，some，every的callback函数中皆可接受三个参数 v - 当前遍历元素 i - 当前遍历元素所在序列号 a - 当前遍历的数组 reduce，reduceRight的callback函数中皆可接受四个参数 prev - 前次迭代return的值 now - 当前迭代的元素 i - 当前迭代元素所在的序列号 a - 当前迭代的数组 好的，基础就此打住。 2. 新增的遍历方法的使用环境 我觉得此块内容才是这篇文章我们需要重点讨论的内容；正如我开头所述，大部分新手都处于要么for循环，要么一直forEach的想法下；我并不是说这两个方法怎么不好，这两个方法是最基础的方法，其他方法也可由这两个方法写出来；可既然有对应的更合适的写法，为什么不选择性使用呢？这不就是和HTML标签的语义化是一个意思么；反正什么标签都可以用，为什么我们需要弄出这么多新标签，搞什么语义化？既然存在那即需要！ forEach - 新增方法中最基础的一个，其他方法亦可由此方法扩展实现，适用于绝大多数情况； map - 最大特点是会返回根据callback函数return的值重组成的新数组，推荐在需要根据数组重组一个新数组时使用；需要注意这里的这个返回新数组；我曾经误以为对象的深复制突然来了一条捷径；但结果却不是我所理解的那样；这里的数组确实是新的，但是数组项如果是复合数据类型，将依然保持引址关系而不是引值；参考示例如下： 12345678910111213141516171819202122232425262728293031323334var test1 = [1, &quot;abc&quot;, undefined, null, true];var test2 = [&#123;a: 1&#125;,&#123;a: 1&#125;,&#123;a: 2&#125;,&#123;a: 1&#125;];//数据项为基本数据类型时的数组快速复制var copyTest1 = test1.slice(0);var copyTest2 = test1.map(function(v)&#123; return v;&#125;);console.log(copyTest1); // [1, &quot;abc&quot;, undefined, null, true]console.log(copyTest2); // [1, &quot;abc&quot;, undefined, null, true]test1[0] = 23;test1.splice(4,1);console.log(test1); // [23, &quot;abc&quot;, undefined]console.log(copyTest1); // [1, &quot;abc&quot;, undefined, null, true]console.log(copyTest2); // [1, &quot;abc&quot;, undefined, null, true]//数据项为复合数据类型时的数组快速复制var copyTest3 = JSON.parse(JSON.stringify(test2));var copyTest4 = test2.map(function(v)&#123; return v;&#125;);console.log(JSON.stringify(copyTest3)); // [&#123;&quot;a&quot;:1&#125;,&#123;&quot;a&quot;:1&#125;,&#123;&quot;a&quot;:2&#125;,&#123;&quot;a&quot;:1&#125;]console.log(JSON.stringify(copyTest4)); // [&#123;&quot;a&quot;:1&#125;,&#123;&quot;a&quot;:1&#125;,&#123;&quot;a&quot;:2&#125;,&#123;&quot;a&quot;:1&#125;]test2[0].a = 23;test2.splice(3,1);console.log(JSON.stringify(test2)); // [&#123;&quot;a&quot;:23&#125;,&#123;&quot;a&quot;:1&#125;,&#123;&quot;a&quot;:2&#125;]console.log(JSON.stringify(copyTest3)); // [&#123;&quot;a&quot;:1&#125;,&#123;&quot;a&quot;:1&#125;,&#123;&quot;a&quot;:2&#125;,&#123;&quot;a&quot;:1&#125;]console.log(JSON.stringify(copyTest4)); // [&#123;&quot;a&quot;:23&#125;,&#123;&quot;a&quot;:1&#125;,&#123;&quot;a&quot;:2&#125;,&#123;&quot;a&quot;:1&#125;] 通过以上代码我们可以看到： 当数组项为基本数据类型时的两种复制方法均可实现完全复制，原数组的改动不会对既有复制数据产生影响； 当数组项为复合数据类型的两种复制方法中，利用序列化反序列化复制的数据完美的实现了深度复制；具体介绍可参照我的这篇博文；而利用map返回新数组的形式复制的数据，数组本身不会受原有数组改变的影响，但是数组项却会受到影响；使用时应当予以注意； filter - 特点是会返回根据callback函数return的真值的元素重组成的新数组，推荐在需要对数组进行过滤部分数据时使用；此处的新数组注意点与map一致，不再重复表述； some - 特点是遇到callback函数return的值为真值时即停止遍历，推荐在寻找数组中是否存在某复合数据类型元素（仅判定值是否相等），寻找复合元素某项值时使用；参考如下： 123456789var test = [&#123;id: 1, name: &quot;张三&quot;&#125;,&#123;id: 2, name: &quot;李四&quot;&#125;,&#123;id: 3, name: &quot;王五&quot;&#125;,&#123;id: 4, name: &quot;赵六&quot;&#125;];//寻找对象中id为3的人的姓名test.some(function(v)&#123; if(v.id == 3)&#123; console.log(v.name); // 王五 return true; &#125;&#125;); every - 特点是返回每项是否都匹配的结果，事实上此项某种程度来说是可以被some替代的，举例来说：every是所有项都返回真值方能判定真值，用some来表达即：有一项返回了反义真值，即判定真值；参考如下： 123456789101112var test = [&#123;a: 1&#125;,&#123;a: 1&#125;,&#123;a: 2&#125;,&#123;a: 1&#125;];var everyFlag = test.every(function(v)&#123; return v.a == 1;&#125;);var someFlag = !test.some(function(v)&#123; return v.a != 1;&#125;);console.log(everyFlag); // falseconsole.log(someFlag); //false indexOf - 返回匹配的系列号，属于数组类型的遍历，之前已有了字符串的遍历；但需要注意此遍历查询建议只用在数组项为基本数据类型时；当数组项为复合数据类型的遍历因为有传址不传值的特性，此时遍历通常是返回-1的；如果你只是需要判定字面上的值是否一致而不考虑存储地址是否一致的话，我建议您使用以下这种方法： 12345678910111213141516var test = [&#123;a: 1&#125;,&#123;a: 1&#125;,&#123;a: 2&#125;,&#123;a: 1&#125;];var b = &#123;a: 2&#125;;var indexFlag = test.indexOf(b);var someFlag = -1;test.some(function(v,i)&#123; if(JSON.stringify(v) == JSON.stringify(b))&#123; someFlag = i; return true; &#125;&#125;);console.log(c); //-1console.log(d); //2 reduce - 迭代处理的方法，推荐这个方法用在前后元素存在计算关系的情况；例如计算数组元素之和，找出数组复合元素某项的最大值等，可参照如下 12345678910111213141516var test1 = [20,62,387,36,154];var test2 = [&#123;id: 1, value: 20&#125;,&#123;id: 2, value: 62&#125;,&#123;id: 3, value: 387&#125;,&#123;id: 4, value: 36&#125;,&#123;id: 5, value: 154&#125;];//简单数组的最大值找法var maxValue = Math.max.apply(&#123;&#125;,test1); //387var maxValue2 = test1.reduce(function(prev,now)&#123; return now &gt; prev ? now : prev;&#125;);console.log(maxValue2); // 387//复合数组的最大值找法var maxValue3 = test2.reduce(function(prev,now)&#123; return now.value &gt; prev.value ? now : prev;&#125;);console.log(maxValue3.value); // 387 总结 我们可以对ES5新增的几个遍历方法总结出以下表 方法名 使用需求 forEach 几乎均可 map 需要重组数组或创建新数组时 filter 不改动数组内部数据，仅进行数组过滤时 some 进行单一条件判断时使用 every 进行全部条件判断时使用 indexOf 或 lastIndexOf 进行数组项序列号查询时 reduce 或 reduceRight 需要对数组前后项进行运算关系计算时使用 至此，我的这篇ES5新增数组遍历方法的小结予以结束，希望更多的成员能够在理解api使用环境的情况下选择合适的方法，既能满足各项需求，又能写出优美好看的代码；谢谢~","tags":[{"name":"前端","slug":"前端","permalink":"https://404blog.cn/tags/前端/"},{"name":"JS","slug":"JS","permalink":"https://404blog.cn/tags/JS/"},{"name":"ES5","slug":"ES5","permalink":"https://404blog.cn/tags/ES5/"},{"name":"原创","slug":"原创","permalink":"https://404blog.cn/tags/原创/"}]},{"title":"总有你没看过的css透明度全总结","date":"2017-02-27T15:01:21.000Z","path":"2017/02/27/总有你没看过的css透明度全总结/","text":"日常吐槽 最近写页面要兼容IE8，这让我用了一年多vue的人转回来玩Jquery，不停的addClass,removeClass,attr….要多糟心有多糟心了~这不，IE8透明度这兼容问题又来了么;废话不多说，马上总结开始。 内容概要 在以下总结内容，你将看到 opacity的适用情况; IE9+透明度的最佳替代方案； IE8-的透明度常规兼容方法； 利用套路反杀IE8-兼容； 内容开始 1, 需求描述如下图要求实现底色为蓝色且具有一定透明度的横幅效果 2, 常规方法及兼容方法很多第一次做透明度的人脑袋一拍就想到了CSS3的opacity，即 2.1, 方案一: opacity1234567div&#123; /*其他属性设置此处不再概述*/ /*........*/ color: #fff; background-color: #00008b; opacity: 0.5;&#125; 总体外观来说不是差别很明显，但仔细一比较还是发现，里面的内容也被透明了，细看文字也没这么亮的感觉。 优点：最容易想到 缺点：子元素会继承透明度，不符需求 方案一不行，就开始有人百度结果了，然后很快会查到CSS3的另一个透明度写法，即 2.2, 方案二: RGBA123456div&#123; /*其他属性设置此处不再概述*/ /*........*/ color: #fff; background-color: rgba(0, 0, 139,0.5);&#125; 效果完美实现，但是在IE8及以下的浏览器中，全挂了；如果我们只为了得出这一个解法，那也不能叫全总结了；另外个人吐槽一下这个写法，每次都要转颜色格式很烦的有木有！ 优点：完美实现 缺点：不兼容低版本浏览器，颜色值转换略烦 一想到透明度IE8兼容,立马就有人想到了ie的filter滤镜，即 2.3, 方案三: filter: alpha(opacity=XX)1234567div&#123; /*其他属性设置此处不再概述*/ /*........*/ filter:alpha(opacity=50); -ms-filter:&quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=50)&quot;; filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=50);&#125; 此方案是这次讨论方案中最差劲的一个，原则上来说是完全实现不了本次需求，原因如下 该方案与我们讨论的opacity是类似的，子节点会继承透明度； 该方案中，我们会考虑IE8中正常底色，IE9中透明底色，然后再用滤镜去透明；事实上，IE中的background-color的 transparent属性存在兼容问题，它会被解析成background: none；最终导致css的hack失败，IE中全部无底色了； 该方案中利用滤镜去透明这一步，我们会想在IE8的时候用filter，IE9使用rgba即可，事实上，这个滤镜在ie8及ie9下 皆能被解析，从而导致ie9双重透明 以上3条原因导致此方案完全不可实现当前需求，不过作为兼容方法的一种还是值得留意的 优点：终于兼容了 缺点：对不上需求 以上方法都不行后，很多人就要祭出大招了~~ 2.4, 方案四: 万能贴图法123div&#123; background: url(...) left top repeat;&#125; 这个方法就是事先按透明度切除一个10*10的透明图层，然后通过背景图重复的方法达到底色透明的目的； 优点：万能 缺点：透明度不确定，颜色不确定时，工作量很大，不够灵活 3，利用套路兼得需求和兼容 3.1,套路一：你走你的道，我过我的桥 我们在2.1方案和2.3的缺点上都提到了一点，即子节点会被继承透明度的问题；那么我们换个想法，我们把透明度设在一个 空节点上不就不影响其他节点上了么，然后在利用定位，把他铺满到全屏最底层就解决了；如下： 1234567891011121314151617181920212223div&#123; /*其他属性设置此处不再概述*/ /*........*/ position: relative;&#125; div:before&#123; content: &quot;&quot;; width: 100%; height: 100%; position: absolute; left: 0; top: 0; z-index: 0; background-color: #00008b; opacity: 0.5; -ms-filter:&quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=50)&quot;; filter:alpha(opacity=50); filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=50);&#125;div &gt; ...&#123; position: ..., z-index: 10&#125; 这样就完美隔离了透明度影响节点的问题，唯一麻烦的是需要把当前节点下的其余节点嵌套到一个容器里去，然后设 置合适的z-index值； 当然以上方法中有个问题即是IE8中不支持伪元素颜色的透明，所以需要做到IE8兼容的情况，就需要自己手动的在节 点下做一个底色透明容器,即: 1234567891011121314div &gt; .before&#123; content: &quot;&quot;; width: 100%; height: 100%; position: absolute; left: 0; top: 0; z-index: 0; background-color: #00008b; opacity: 0.5; -ms-filter:&quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=50)&quot;; filter:alpha(opacity=50); filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=50); &#125; 3.2,套路二：狭路相逢不要脸的胜，不行就强上 我们讨论了这么多透明度的方法，在不考虑兼容的情况下，效果最完美的就是 方案二：RGBA了，然后遇到IE8，能否有兼容办法呢，答案是有的，这里我们要用到一下IE滤镜中的渐变滤镜了，即1filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=XXX,endColorstr=XXX) 我们需要传进去的参数就两个，渐变起始色和渐变结束色，我们只需要透明即可，不需要渐变；因此起始色和渐变色是一致的，而这个渐变滤镜的颜色传值共9位，即1#AABBBBBB 包含三个部分组成的， 第一部分是固定的#符号， 第二部分是颜色的透明度，该透明度的计算方法是1[0-1]之间的透明值*255，然后转换为16进制 在这里我列举一些常用的透明度对应值以供参考： 透明值 转换后16进制值 0.1 19 0.2 33 0.3 4C 0.4 66 0.5 7F 0.6 99 0.7 B2 0.8 C8 0.9 E5 3.是被透明颜色的16进制，即我们常写的FFFFFF,000000等等举例来说：即是1234567div&#123; /*其他属性设置此处不再概述*/ /*........*/ color: #fff; background-color: rgba(0, 0, 139,0.5); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#7F00008B,endColorstr=#7F00008B)&#125; 总结 我们对透明度的用法做了一个总结如下表 方法 优点 缺点 opacity 简单 不兼容IE，透明继承 rgba 简单 不兼容IE，透明不继承 alpha滤镜 仅IE适用 兼容性不好控制，透明继承 贴图 万能 麻烦，灵活性性差 透明空容器法 兼容IE 需要变更结构 gradient滤镜 仅IE适用 需要计算色值 通过以上总结，希望再次遇见透明度的相关需求的时候，能够选择合适的搭配，找到鱼和熊掌兼得的方法","tags":[{"name":"前端","slug":"前端","permalink":"https://404blog.cn/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"https://404blog.cn/tags/CSS/"},{"name":"原创","slug":"原创","permalink":"https://404blog.cn/tags/原创/"},{"name":"透明度","slug":"透明度","permalink":"https://404blog.cn/tags/透明度/"},{"name":"套路","slug":"套路","permalink":"https://404blog.cn/tags/套路/"}]},{"title":"有关list-style的一点查缺补漏","date":"2017-02-23T14:28:17.000Z","path":"2017/02/23/list-style的查缺补漏/","text":"今天做页面的时候遇到list-style设置失效的问题，具体的需求是这样的：固定容器的高，内部有左右两侧，左侧为一张缩略图；右侧分为上下两部分，上部分为标题，下部分为一列表； 要求：实现鼠标移上去去的时候展开列表，且把列表标记显示为方块；如下图 悬浮前： 悬浮后： 结构搭建和样式都很简单，但却遇到了一个问题是；默认我的写法是 123456789101112ul &gt; li&#123; list-style: none; display: none; color: #cc8167;&#125;ul &gt; li:first-child&#123; display: block;&#125;div.a:hover li&#123; display: block; list-style: square inside;&#125; 这种写法始终无效，鼠标放上去其他属性很正常，就是列表标记不出来；查了网上资源，多是说float影响或者距离不够，但我并未float且已设置为 1list-style-position: inside 不应该出现的呀，后来去w3cschoo再次细看了这个属性，发现了这一句 该属性是一个简写属性，涵盖了所有其他列表样式属性。由于它应用到所有 display 为 list-item 的元素，所以在普通的 HTML 和 XHTML 中只能用于 li 元素，不过实际上它可以应用到任何元素，并由 list-item 元素继承。 你可以点击这里去看详细说明； 然后修改代码为 123456789101112ul &gt; li&#123; list-style: none; display: none; color: #cc8167;&#125;ul &gt; li:first-child&#123; display: list-item;&#125;div.a:hover li&#123; display: list-item; list-style: square inside;&#125; 这样就可以了；也算是差缺补漏了一个知识点，另外这个属性值可以设3个，其中第三个可以设为自定义图片还是很方便的 这个问题解决了，新的问题来了，不同浏览器之间，这个列表标记与文字之间的间距并不一致，甚至可以说是过大了，这又成了个问题；这我暂时没有找到可行的方法，有知道的麻烦指教一下， 最终我还是采用了before伪元素的形式去实现的，毕竟这种方式间距控制还是很简单的。","tags":[{"name":"前端","slug":"前端","permalink":"https://404blog.cn/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"https://404blog.cn/tags/CSS/"}]}]