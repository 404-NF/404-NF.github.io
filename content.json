[{"title":"ES2016数组新增遍历方法的使用环境总结","date":"2017-03-07T14:14:44.000Z","path":"2017/03/07/ES5新增遍历方法总结/","text":"日常吐槽 其实当我坐在公交车上用手机敲下这个标题的时候，我还在迟疑要不要写这么一篇总结。 一来ES5新增的这几个遍历方法网上早就是铺天盖地的基础介绍，随手检索一下就千篇一律的文章; 二来可即便如此，我发现很多的团队成员却依然沉醉在ES3的for循环里久久不能自拔，再或者就是不管什么情况的循环，只要forEach就好了，只会forEach就好了！技术不懂得更新，那还和咸鱼有什么区别呢~ 所以这里我就根据我前段时间写的大量的业务代码来总结一下新增的这几个方法，欢迎指出问题及补充！ 内容概要 在本篇文章总价中,您将看到以下内容 ES5数组新增了哪些遍历方法 ES5数组新增的方法的使用概述 ES5数组新增方法的合适使用环境 利用ES5新增的方法，我们可衍生出的写法 内容开始 1. 新增的遍历方法及其含义 这块部分是网上同类化文章最多的部分，在此我并不想过多的表述；我觉得我的博客应该定位于在有基础知识的前提下去探索不要脸的套路与技术及衍生发展，而不是反复的介绍基础知识，程序这行还是需要会自己学习的能力的；这就好比我在介绍怎么和女友亲亲妮妮的了，你却说你没女朋友~~~; 不过为了照顾部分看众，我还是总结了一个表格概述基础内容，如您需要更多信息，我建议您点击这里查看张鑫旭大神的这篇详细介绍文章； 方法名 传参形式 备注 forEach callback,[ thisObject] 返回undefined map callback,[ thisObject] 返回callback函数return的值所组成的新数组 filter callback,[ thisObject] 返回callback函数return的值为真值的对应元素所组成的新数组 some callback,[ thisObject] 返回布尔值，特性：匹配到真值一次即停止遍历 every callback,[ thisObject] 返回布尔值，特性：匹配到假值一次即停止遍历 indexOf searchElement[, fromIndex] 返回匹配元素所在的序列号 lastIndexOf searchElement[, fromIndex] 返回匹配元素所在的序列号 reduce callback[, initialValue] 返回迭代值，callback函数的首个参数即为上次遍历的return值或initialValue reduceRight callback[, initialValue] 返回迭代值，callback函数的首个参数即为上次遍历的return值或initialValue 在这些方法中：forEach，map，filter，some，every的callback函数中皆可接受三个参数 v - 当前遍历元素 i - 当前遍历元素所在序列号 a - 当前遍历的数组 reduce，reduceRight的callback函数中皆可接受四个参数 prev - 前次迭代return的值 now - 当前迭代的元素 i - 当前迭代元素所在的序列号 a - 当前迭代的数组 好的，基础就此打住。 2. 新增的遍历方法的使用环境 我觉得此块内容才是这篇文章我们需要重点讨论的内容；正如我开头所述，大部分新手都处于要么for循环，要么一直forEach的想法下；我并不是说这两个方法怎么不好，这两个方法是最基础的方法，其他方法也可由这两个方法写出来；可既然有对应的更合适的写法，为什么不选择性使用呢？这不就是和HTML标签的语义化是一个意思么；反正什么标签都可以用，为什么我们需要弄出这么多新标签，搞什么语义化？既然存在那即需要！ forEach - 新增方法中最基础的一个，其他方法亦可由此方法扩展实现，适用于绝大多数情况； map - 最大特点是会返回根据callback函数return的值重组成的新数组，推荐在需要根据数组重组一个新数组时使用；需要注意这里的这个返回新数组；我曾经误以为对象的深复制突然来了一条捷径；但结果却不是我所理解的那样；这里的数组确实是新的，但是数组项如果是复合数据类型，将依然保持引址关系而不是引值；参考示例如下： 12345678910111213141516171819202122232425262728293031323334var test1 = [1, &quot;abc&quot;, undefined, null, true];var test2 = [&#123;a: 1&#125;,&#123;a: 1&#125;,&#123;a: 2&#125;,&#123;a: 1&#125;];//数据项为基本数据类型时的数组快速复制var copyTest1 = test1.slice(0);var copyTest2 = test1.map(function(v)&#123; return v;&#125;);console.log(copyTest1); // [1, &quot;abc&quot;, undefined, null, true]console.log(copyTest2); // [1, &quot;abc&quot;, undefined, null, true]test1[0] = 23;test1.splice(4,1);console.log(test1); // [23, &quot;abc&quot;, undefined]console.log(copyTest1); // [1, &quot;abc&quot;, undefined, null, true]console.log(copyTest2); // [1, &quot;abc&quot;, undefined, null, true]//数据项为复合数据类型时的数组快速复制var copyTest3 = JSON.parse(JSON.stringify(test2));var copyTest4 = test2.map(function(v)&#123; return v;&#125;);console.log(JSON.stringify(copyTest3)); // [&#123;&quot;a&quot;:1&#125;,&#123;&quot;a&quot;:1&#125;,&#123;&quot;a&quot;:2&#125;,&#123;&quot;a&quot;:1&#125;]console.log(JSON.stringify(copyTest4)); // [&#123;&quot;a&quot;:1&#125;,&#123;&quot;a&quot;:1&#125;,&#123;&quot;a&quot;:2&#125;,&#123;&quot;a&quot;:1&#125;]test2[0].a = 23;test2.splice(3,1);console.log(JSON.stringify(test2)); // [&#123;&quot;a&quot;:23&#125;,&#123;&quot;a&quot;:1&#125;,&#123;&quot;a&quot;:2&#125;]console.log(JSON.stringify(copyTest3)); // [&#123;&quot;a&quot;:1&#125;,&#123;&quot;a&quot;:1&#125;,&#123;&quot;a&quot;:2&#125;,&#123;&quot;a&quot;:1&#125;]console.log(JSON.stringify(copyTest4)); // [&#123;&quot;a&quot;:23&#125;,&#123;&quot;a&quot;:1&#125;,&#123;&quot;a&quot;:2&#125;,&#123;&quot;a&quot;:1&#125;] 通过以上代码我们可以看到： 当数组项为基本数据类型时的两种复制方法均可实现完全复制，原数组的改动不会对既有复制数据产生影响； 当数组项为复合数据类型的两种复制方法中，利用序列化反序列化复制的数据完美的实现了深度复制；具体介绍可参照我的这篇博文；而利用map返回新数组的形式复制的数据，数组本身不会受原有数组改变的影响，但是数组项却会受到影响；使用时应当予以注意； filter - 特点是会返回根据callback函数return的真值的元素重组成的新数组，推荐在需要对数组进行过滤部分数据时使用；此处的新数组注意点与map一致，不再重复表述； some - 特点是遇到callback函数return的值为真值时即停止遍历，推荐在寻找数组中是否存在某复合数据类型元素（仅判定值是否相等），寻找复合元素某项值时使用；参考如下： 123456789var test = [&#123;id: 1, name: &quot;张三&quot;&#125;,&#123;id: 2, name: &quot;李四&quot;&#125;,&#123;id: 3, name: &quot;王五&quot;&#125;,&#123;id: 4, name: &quot;赵六&quot;&#125;];//寻找对象中id为3的人的姓名test.some(function(v)&#123; if(v.id == 3)&#123; console.log(v.name); // 王五 return true; &#125;&#125;); every - 特点是返回每项是否都匹配的结果，事实上此项某种程度来说是可以被some替代的，举例来说：every是所有项都返回真值方能判定真值，用some来表达即：有一项返回了反义真值，即判定真值；参考如下： 123456789101112var test = [&#123;a: 1&#125;,&#123;a: 1&#125;,&#123;a: 2&#125;,&#123;a: 1&#125;];var everyFlag = test.every(function(v)&#123; return v.a == 1;&#125;);var someFlag = !test.some(function(v)&#123; return v.a != 1;&#125;);console.log(everyFlag); // falseconsole.log(someFlag); //false indexOf - 返回匹配的系列号，属于数组类型的遍历，之前已有了字符串的遍历；但需要注意此遍历查询建议只用在数组项为基本数据类型时；当数组项为复合数据类型的遍历因为有传址不传值的特性，此时遍历通常是返回-1的；如果你只是需要判定字面上的值是否一致而不考虑存储地址是否一致的话，我建议您使用以下这种方法： 12345678910111213141516var test = [&#123;a: 1&#125;,&#123;a: 1&#125;,&#123;a: 2&#125;,&#123;a: 1&#125;];var b = &#123;a: 2&#125;;var indexFlag = test.indexOf(b);var someFlag = -1;test.some(function(v,i)&#123; if(JSON.stringify(v) == JSON.stringify(b))&#123; someFlag = i; return true; &#125;&#125;);console.log(c); //-1console.log(d); //2 reduce - 迭代处理的方法，推荐这个方法用在前后元素存在计算关系的情况；例如计算数组元素之和，找出数组复合元素某项的最大值等，可参照如下 12345678910111213141516var test1 = [20,62,387,36,154];var test2 = [&#123;id: 1, value: 20&#125;,&#123;id: 2, value: 62&#125;,&#123;id: 3, value: 387&#125;,&#123;id: 4, value: 36&#125;,&#123;id: 5, value: 154&#125;];//简单数组的最大值找法var maxValue = Math.max.apply(&#123;&#125;,test1); //387var maxValue2 = test1.reduce(function(prev,now)&#123; return now &gt; prev ? now : prev;&#125;);console.log(maxValue2); // 387//复合数组的最大值找法var maxValue3 = test2.reduce(function(prev,now)&#123; return now.value &gt; prev.value ? now : prev;&#125;);console.log(maxValue3.value); // 387 总结 我们可以对ES5新增的几个遍历方法总结出以下表 方法名 使用需求 forEach 几乎均可 map 需要重组数组或创建新数组时 filter 不改动数组内部数据，仅进行数组过滤时 some 进行单一条件判断时使用 every 进行全部条件判断时使用 indexOf 或 lastIndexOf 进行数组项序列号查询时 reduce 或 reduceRight 需要对数组前后项进行运算关系计算时使用 至此，我的这篇ES5新增数组遍历方法的小结予以结束，希望更多的成员能够在理解api使用环境的情况下选择合适的方法，既能满足各项需求，又能写出优美好看的代码；谢谢~","tags":[{"name":"前端","slug":"前端","permalink":"https://404-NF.github.io/tags/前端/"},{"name":"JS","slug":"JS","permalink":"https://404-NF.github.io/tags/JS/"},{"name":"ES5","slug":"ES5","permalink":"https://404-NF.github.io/tags/ES5/"},{"name":"原创","slug":"原创","permalink":"https://404-NF.github.io/tags/原创/"}]},{"title":"总有你没看过的css透明度全总结","date":"2017-02-27T15:01:21.000Z","path":"2017/02/27/总有你没看过的css透明度全总结/","text":"日常吐槽 最近写页面要兼容IE8，这让我用了一年多vue的人转回来玩Jquery，不停的addClass,removeClass,attr….要多糟心有多糟心了~这不，IE8透明度这兼容问题又来了么;废话不多说，马上总结开始。 内容概要 在以下总结内容，你将看到 opacity的适用情况; IE9+透明度的最佳替代方案； IE8-的透明度常规兼容方法； 利用套路反杀IE8-兼容； 内容开始 1, 需求描述如下图要求实现底色为蓝色且具有一定透明度的横幅效果 2, 常规方法及兼容方法很多第一次做透明度的人脑袋一拍就想到了CSS3的opacity，即 2.1, 方案一: opacity1234567div&#123; /*其他属性设置此处不再概述*/ /*........*/ color: #fff; background-color: #00008b; opacity: 0.5;&#125; 总体外观来说不是差别很明显，但仔细一比较还是发现，里面的内容也被透明了，细看文字也没这么亮的感觉。 优点：最容易想到 缺点：子元素会继承透明度，不符需求 方案一不行，就开始有人百度结果了，然后很快会查到CSS3的另一个透明度写法，即 2.2, 方案二: RGBA123456div&#123; /*其他属性设置此处不再概述*/ /*........*/ color: #fff; background-color: rgba(0, 0, 139,0.5);&#125; 效果完美实现，但是在IE8及以下的浏览器中，全挂了；如果我们只为了得出这一个解法，那也不能叫全总结了；另外个人吐槽一下这个写法，每次都要转颜色格式很烦的有木有！ 优点：完美实现 缺点：不兼容低版本浏览器，颜色值转换略烦 一想到透明度IE8兼容,立马就有人想到了ie的filter滤镜，即 2.3, 方案三: filter: alpha(opacity=XX)1234567div&#123; /*其他属性设置此处不再概述*/ /*........*/ filter:alpha(opacity=50); -ms-filter:&quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=50)&quot;; filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=50);&#125; 此方案是这次讨论方案中最差劲的一个，原则上来说是完全实现不了本次需求，原因如下 该方案与我们讨论的opacity是类似的，子节点会继承透明度； 该方案中，我们会考虑IE8中正常底色，IE9中透明底色，然后再用滤镜去透明；事实上，IE中的background-color的 transparent属性存在兼容问题，它会被解析成background: none；最终导致css的hack失败，IE中全部无底色了； 该方案中利用滤镜去透明这一步，我们会想在IE8的时候用filter，IE9使用rgba即可，事实上，这个滤镜在ie8及ie9下 皆能被解析，从而导致ie9双重透明 以上3条原因导致此方案完全不可实现当前需求，不过作为兼容方法的一种还是值得留意的 优点：终于兼容了 缺点：对不上需求 以上方法都不行后，很多人就要祭出大招了~~ 2.4, 方案四: 万能贴图法123div&#123; background: url(...) left top repeat;&#125; 这个方法就是事先按透明度切除一个10*10的透明图层，然后通过背景图重复的方法达到底色透明的目的； 优点：万能 缺点：透明度不确定，颜色不确定时，工作量很大，不够灵活 3，利用套路兼得需求和兼容 3.1,套路一：你走你的道，我过我的桥 我们在2.1方案和2.3的缺点上都提到了一点，即子节点会被继承透明度的问题；那么我们换个想法，我们把透明度设在一个 空节点上不就不影响其他节点上了么，然后在利用定位，把他铺满到全屏最底层就解决了；如下： 1234567891011121314151617181920212223div&#123; /*其他属性设置此处不再概述*/ /*........*/ position: relative;&#125; div:before&#123; content: &quot;&quot;; width: 100%; height: 100%; position: absolute; left: 0; top: 0; z-index: 0; background-color: #00008b; opacity: 0.5; -ms-filter:&quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=50)&quot;; filter:alpha(opacity=50); filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=50);&#125;div &gt; ...&#123; position: ..., z-index: 10&#125; 这样就完美隔离了透明度影响节点的问题，唯一麻烦的是需要把当前节点下的其余节点嵌套到一个容器里去，然后设 置合适的z-index值； 当然以上方法中有个问题即是IE8中不支持伪元素颜色的透明，所以需要做到IE8兼容的情况，就需要自己手动的在节 点下做一个底色透明容器,即: 1234567891011121314div &gt; .before&#123; content: &quot;&quot;; width: 100%; height: 100%; position: absolute; left: 0; top: 0; z-index: 0; background-color: #00008b; opacity: 0.5; -ms-filter:&quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=50)&quot;; filter:alpha(opacity=50); filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=50); &#125; 3.2,套路二：狭路相逢不要脸的胜，不行就强上 我们讨论了这么多透明度的方法，在不考虑兼容的情况下，效果最完美的就是 方案二：RGBA了，然后遇到IE8，能否有兼容办法呢，答案是有的，这里我们要用到一下IE滤镜中的渐变滤镜了，即1filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=XXX,endColorstr=XXX) 我们需要传进去的参数就两个，渐变起始色和渐变结束色，我们只需要透明即可，不需要渐变；因此起始色和渐变色是一致的，而这个渐变滤镜的颜色传值共9位，即1#AABBBBBB 包含三个部分组成的， 第一部分是固定的#符号， 第二部分是颜色的透明度，该透明度的计算方法是1[0-1]之间的透明值*255，然后转换为16进制 在这里我列举一些常用的透明度对应值以供参考： 透明值 转换后16进制值 0.1 19 0.2 33 0.3 4C 0.4 66 0.5 7F 0.6 99 0.7 B2 0.8 C8 0.9 E5 3.是被透明颜色的16进制，即我们常写的FFFFFF,000000等等举例来说：即是1234567div&#123; /*其他属性设置此处不再概述*/ /*........*/ color: #fff; background-color: rgba(0, 0, 139,0.5); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#7F00008B,endColorstr=#7F00008B)&#125; 总结 我们对透明度的用法做了一个总结如下表 方法 优点 缺点 opacity 简单 不兼容IE，透明继承 rgba 简单 不兼容IE，透明不继承 alpha滤镜 仅IE适用 兼容性不好控制，透明继承 贴图 万能 麻烦，灵活性性差 透明空容器法 兼容IE 需要变更结构 gradient滤镜 仅IE适用 需要计算色值 通过以上总结，希望再次遇见透明度的相关需求的时候，能够选择合适的搭配，找到鱼和熊掌兼得的方法","tags":[{"name":"前端","slug":"前端","permalink":"https://404-NF.github.io/tags/前端/"},{"name":"原创","slug":"原创","permalink":"https://404-NF.github.io/tags/原创/"},{"name":"CSS","slug":"CSS","permalink":"https://404-NF.github.io/tags/CSS/"},{"name":"透明度","slug":"透明度","permalink":"https://404-NF.github.io/tags/透明度/"},{"name":"套路","slug":"套路","permalink":"https://404-NF.github.io/tags/套路/"}]},{"title":"有关list-style的一点查缺补漏","date":"2017-02-23T14:28:17.000Z","path":"2017/02/23/list-style的查缺补漏/","text":"今天做页面的时候遇到list-style设置失效的问题，具体的需求是这样的：固定容器的高，内部有左右两侧，左侧为一张缩略图；右侧分为上下两部分，上部分为标题，下部分为一列表； 要求：实现鼠标移上去去的时候展开列表，且把列表标记显示为方块；如下图 悬浮前： 悬浮后： 结构搭建和样式都很简单，但却遇到了一个问题是；默认我的写法是 123456789101112ul &gt; li&#123; list-style: none; display: none; color: #cc8167;&#125;ul &gt; li:first-child&#123; display: block;&#125;div.a:hover li&#123; display: block; list-style: square inside;&#125; 这种写法始终无效，鼠标放上去其他属性很正常，就是列表标记不出来；查了网上资源，多是说float影响或者距离不够，但我并未float且已设置为 1list-style-position: inside 不应该出现的呀，后来去w3cschoo再次细看了这个属性，发现了这一句 该属性是一个简写属性，涵盖了所有其他列表样式属性。由于它应用到所有 display 为 list-item 的元素，所以在普通的 HTML 和 XHTML 中只能用于 li 元素，不过实际上它可以应用到任何元素，并由 list-item 元素继承。 你可以点击这里去看详细说明； 然后修改代码为 123456789101112ul &gt; li&#123; list-style: none; display: none; color: #cc8167;&#125;ul &gt; li:first-child&#123; display: list-item;&#125;div.a:hover li&#123; display: list-item; list-style: square inside;&#125; 这样就可以了；也算是差缺补漏了一个知识点，另外这个属性值可以设3个，其中第三个可以设为自定义图片还是很方便的 这个问题解决了，新的问题来了，不同浏览器之间，这个列表标记与文字之间的间距并不一致，甚至可以说是过大了，这又成了个问题；这我暂时没有找到可行的方法，有知道的麻烦指教一下， 最终我还是采用了before伪元素的形式去实现的，毕竟这种方式间距控制还是很简单的。","tags":[{"name":"前端","slug":"前端","permalink":"https://404-NF.github.io/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"https://404-NF.github.io/tags/CSS/"}]}]